With the informations we unfolded up to now, we would like to design a library interface with a kernel that complies with the following technical specifications:

\begin{itemize}
	\item The library should be able to start with any amount of memory and extend it whenever needed. Moreover, the memory allocations should remain as scarce as possible.
	\item The kernel should reproduce the behaviour of BLAST-like kernels by allowing local DNA alignment with a non-zero starting score.
	\item The interface on BWA side with the library should approach the behaviour of BLAST-like alignment by calling the kernel and retrieving the alignment scores in the "seed-only" fashion, as explained on section~\ref{sec:seedonly}.
	\item The end product should be readily available with as an open-source project, respectful of the original licenses, and with a complete traceback of the code production.
\end{itemize}

With the specification written, now we have to state the goals and metrics used to verify that the end product meets the bill of specification, that is, that its behaviour meets the following expectations: 

\begin{itemize}
	\item The integration of GASAL2 in BWA should effectively speed up the alignment process. We will compare the kernel execution times before and after acceleration, in seconds. We will also compare the total execution time, to check the difference that hidden-time execution makes.
	
	\item Using the seed-only paradigm should not bring any difference to the vast majority of the alignments. Still, there is no guarantee that the results will be exactly the same. Whenever the alignment differs, the difference with the original BLAST-like paradigm should be minimal. Result correctness will be carefully examined. We will quantify the number of differences between the two results output from BWA and its accelerated version, for our given data sets.
	
	\item The VRAM use should not take more than what it necessary. To verify this, we will take advantage of the feature that should allocate more VRAM when necessary to purposefully initialize the \verb|gpu_storage| structure with a small size and let it grow bigger to just the right amount. This will give us a lower bound that will be by construction close to the actual VRAM usage needed for our data sets.
	
\end{itemize}

In the next chapter, we will detail the choices we made to meet the technical specifications.